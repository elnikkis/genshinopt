---
layout: page
mathjax: true
title: 本ツールの技術的詳細
---

#### ダメージ計算式



#### 聖遺物サブステータスのスコア（コスト）計算式

最適化では，聖遺物のサブステータスに何らかの制約を設けて，その制約条件の元でダメージが最大になるようにサブステータスの配分を最適化します．
[原神Wikiの記述](https://wikiwiki.jp/genshinwiki/%E8%81%96%E9%81%BA%E7%89%A9#ParamSubOps)によると，星5聖遺物のサブステータスの上昇量は以下の表の通りです．


| サブステ         | 上昇量（中） | 
| ---------------- | ------------ | 
| 攻撃力%($a$)          | 4.7%          | 
| 防御力%($b$)          | 5.8%          | 
| HP%($h$)              | 4.7%          | 
| 会心率($c$)           | 3.1%          | 
| 会心ダメージ($d$)     | 6.2%          | 
| 元素チャージ効率($r$) | 5.2%          | 
| 元素熟知($m$)         | 19           | 


<br>

このため，スコア（コスト）計算式は次の通り設定しています．

$$
\mathrm{cost}(\mathbf{x}) = \mathrm{cost}([a, b, h, c, d, r, m]) = 6.2\times \left(\frac{a}{0.047} + \frac{b}{0.058} + \frac{h}{0.047} + \frac{c}{0.031} + \frac{d}{0.062} + \frac{r}{0.052} + \frac{m}{19}\right)
$$

この数式の意味は，一般的によく使われている数式「攻撃力% + 会心率 $\times$ 2 + 会心ダメージ」をより厳密に一般化した数式であると認識していただくのが簡単でしょう．
たとえばサブステータスにおいて攻撃力の4.7%の増加と会心ダメージの6.2%の増加のコストは同じであることを意味しています．
もう少し言えば，コストの値を6.2で割った値が，聖遺物でサブステータス（攻撃力%）が上昇した回数を意味します（ただし，実際には上昇量には振れ幅があるので，現実上の聖遺物では成立しないことに注意してください）．
サブステータスの上昇回数には上限があるため，本サイトではこの計算式をコストとしています．

この計算式を制約とすることで，ユーザーは「聖遺物5つの合計スコア$S$において，ダメージが最大となるサブステータスの配分」を知ることができます．
また，複数の武器や聖遺物セットを比較するとき，比較の前提として「聖遺物5つの合計スコア$S$において最適化されている」状態で比較できます．
そのため，たとえば会心率が伸びる武器と会心ダメージが伸びる武器を比較したいときも，それぞれの最適な状態でステータス配分で比較できるため公平に比較できます．


また，本最適化サイトでは聖遺物の実質的なダメージへの影響度である[聖遺物有効度]()と
聖遺物がどれだけ実現困難かの指標である[聖遺物偏差値]()を利用しています．
これらはスコア（コスト）計算とは異なる概念ですのでご注意ください．



#### 最適化アルゴリズム

最適化したいダメージ計算式$f(\mathbf{x})$を最適化アルゴリズムを用いて最適化します．
最適化問題の定式化は以下のようになります．

$$
\begin{align}
&\text{maximize} &&f(\mathbf{x}) \\
&\text{subject to} &&\mathrm{cost}(\mathbf{x}) \leq S \\
& &&\mathbf{x}_i \geq 0, &\forall i \in \{0,1,\cdots,7\}
\end{align}
$$

最後の制約$\mathbf{x}_i \geq 0$さえなければ，大学で習うラグランジュの未定乗数法で解けるのですが，
最後の制約$\mathbf{x}_i \geq 0$があるので少し厄介です．

目的関数$f(\mathbf{x})$が積の形になっているため，対数を取ることで通信の世界でよく用いられる注水定理が使えるかと考えてみましたが，たとえば会心率と会心ダメージの項は$(1 + cd)$と積になっていたり，HPを攻撃力に変換する効果があったりするので，少し難しそうだと思いました．
それに，今後たとえば「攻撃力を会心率に変換する」なんていうトンデモ効果を持ったキャラや聖遺物が出てくる可能性も0ではない気がするので，もう少し柔軟に最適化する方法を考えました．

そのため，このサイトでは[nlopt](https://nlopt.readthedocs.io/en/latest/)という汎用の非線形最適化ライブラリのJavascriptバインディング[nlopt-js](https://bertrandbev.github.io/nlopt-js/#/)を利用しています．

ただ，先程も記述した通り，目的関数$f(\mathbf{x})$が積の形になっているため，対数を取ることでより簡単な問題に変換できます．
よって，以下の最適化問題をnloptを用いて最適化します．

$$
\begin{align}
&\text{maximize} &&\log f(\mathbf{x}) \\
&\text{subject to} &&\mathrm{cost}(\mathbf{x}) \leq S, \\
& &&\mathbf{x}[i] \geq 0, &\forall i \in \{0,1,\cdots,7\}
\end{align}
$$

実際に開発の段階では，上記のように対数を用いることで局所最適解用のアルゴリズムでも大域最適解に落ち込む確率が大幅に増加し，安定して大域最適解へ落ちていることを確認しています．

単に対数を取るだけで簡単になるなんて不思議に思うかもしれませんが，たとえば次のような積の関数を考えてみましょう．

$$
\begin{align}
f(\mathbf{x}) = f([a, b]) = (1 + a)(1 + b)
\end{align}
$$

この関数$f(\mathbf{x})$を$a,b$でそれぞれ偏微分すると以下のようになります．

$$
\begin{align}
\frac{\partial f}{\partial a} &= (1 + b) \\
\frac{\partial f}{\partial b} &= (1 + a) \\
\end{align}
$$

一方で，対数を取った目的関数とその偏微分は次のようになります．

$$
\begin{align}
\log f(\mathbf{x}) &= \log(1+a) + \log(1 + b) \\
\frac{\partial \log f}{\partial a} &= \frac{1}{1 + a} \\
\frac{\partial \log f}{\partial b} &= \frac{1}{1 + b} \\
\end{align}
$$

対数を取る前は$a$での偏微分の値が$b$に依存していますが，対数を取ると$a$での偏微分の値は$b$に依存しないことがわかります．
原神におけるダメージの最適化問題も先程の例のようにパラメータの積の形になっているため，同様の原理でより簡単に解けるようになります．
もちろん，目的関数の対数をとってもいい理由は対数が単調増加関数なためです．

また，本サイトのプログラムでは，複雑なダメージ計算式を手で微分する手間を無くしたり柔軟性を向上させるために，いわゆる計算グラフの構築と自動微分（たとえばautogradのような）をする簡単なプログラムを組んでいます．
このため，HPを攻撃力に変換したり，チャージ効率をダメージバフに変換するような効果があっても，人間が個別に数式を用意して微分する必要はありません．
プログラムが各キャラや聖遺物セットに基づいたダメージの計算式を自動で構築して，そこからダメージ値と同時に勾配ベクトル（偏微分）まで自動計算します．

